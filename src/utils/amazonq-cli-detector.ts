/**
 * Amazon Q CLI Version Detection and Compatibility
 * Detects different versions of Amazon Q CLI and adapts command generation
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { Logger } from './logger';

const execAsync = promisify(exec);

export interface AmazonQCLIInfo {
  /** Available command name (q, qchat, etc.) */
  command: string;
  /** CLI version if detectable */
  version?: string;
  /** Whether it supports --file flag */
  supportsFileFlag: boolean;
  /** Whether it supports --context flag */
  supportsContextFlag: boolean;
  /** Command structure type */
  type: 'q-chat' | 'qchat-chat' | 'unknown';
  /** Full help output for debugging */
  helpOutput?: string;
}

export class AmazonQCLIDetector {
  private logger: Logger;
  private cachedInfo: AmazonQCLIInfo | null = null;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  /**
   * Detect Amazon Q CLI version and capabilities
   */
  async detectCLI(): Promise<AmazonQCLIInfo> {
    if (this.cachedInfo) {
      return this.cachedInfo;
    }

    this.logger.verbose('Detecting Amazon Q CLI version and capabilities...');

    // Try different command variations
    const candidates = [
      { cmd: 'q', subcommand: 'chat' },
      { cmd: 'qchat', subcommand: 'chat' },
      { cmd: 'amazon-q', subcommand: 'chat' },
      { cmd: 'amazonq', subcommand: 'chat' }
    ];

    for (const candidate of candidates) {
      try {
        const info = await this.testCommand(candidate.cmd, candidate.subcommand);
        if (info) {
          this.cachedInfo = info;
          this.logger.verbose(`Detected Amazon Q CLI: ${info.command} (${info.type})`);
          return info;
        }
      } catch (error) {
        this.logger.debug(`Command ${candidate.cmd} not available: ${error}`);
      }
    }

    throw new Error('Amazon Q CLI not found. Please install Amazon Q CLI.');
  }

  /**
   * Test a specific command variant
   */
  private async testCommand(cmd: string, subcommand: string): Promise<AmazonQCLIInfo | null> {
    try {
      // Test if command exists and get help
      const helpResult = await execAsync(`${cmd} ${subcommand} --help`, { 
        timeout: 5000 
      });
      
      const helpOutput = helpResult.stdout + helpResult.stderr;
      
      // Test version command
      let version: string | undefined;
      try {
        const versionResult = await execAsync(`${cmd} --version`, { timeout: 3000 });
        version = versionResult.stdout.trim();
      } catch {
        // Version command might not exist
        this.logger.debug(`No version command for ${cmd}`);
      }

      // Analyze help output to determine capabilities
      const supportsFileFlag = helpOutput.includes('--file') || helpOutput.includes('-f');
      const supportsContextFlag = helpOutput.includes('--context') || helpOutput.includes('--ctx');
      
      // Determine command type
      let type: AmazonQCLIInfo['type'] = 'unknown';
      if (cmd === 'q' && subcommand === 'chat') {
        type = 'q-chat';
      } else if (cmd === 'qchat' && subcommand === 'chat') {
        type = 'qchat-chat';
      }

      return {
        command: cmd,
        version,
        supportsFileFlag,
        supportsContextFlag,
        type,
        helpOutput: helpOutput.substring(0, 1000) // Truncate for logging
      };

    } catch (error) {
      this.logger.debug(`Failed to test ${cmd} ${subcommand}: ${error}`);
      return null;
    }
  }

  /**
   * Generate appropriate command line for given CLI type
   */
  generateCommandLine(info: AmazonQCLIInfo, templatePath?: string, contextFiles?: string[]): string[] {
    const parts = [info.command];
    
    // Add subcommand based on type
    if (info.type === 'q-chat' || info.type === 'qchat-chat') {
      parts.push('chat');
    }

    // Add file flag if supported and template provided
    if (templatePath && info.supportsFileFlag) {
      parts.push('--file', templatePath);
    }

    // Add context files if supported
    if (contextFiles && info.supportsContextFlag) {
      contextFiles.forEach(file => {
        parts.push('--context', file);
      });
    }

    return parts;
  }

  /**
   * Generate script content that works with detected CLI
   */
  generateScriptContent(info: AmazonQCLIInfo, commandName: string, description: string): string {
    const scriptTemplate = `#!/bin/bash
# ${description}
# Generated by amazonq-sdd v0.1.1 - Compatible with ${info.command} (${info.type})

set -euo pipefail

# Check if Amazon Q CLI is available
if ! command -v ${info.command} &> /dev/null; then
    echo "Error: Amazon Q CLI command '${info.command}' not found. Please install Amazon Q CLI."
    echo "Install from: https://aws.amazon.com/q/developer/"
    exit 1
fi

# Check if .amazonq directory exists
if [ ! -d ".amazonq" ]; then
    echo "Error: .amazonq directory not found. Run 'npx amazonq-sdd@latest' first."
    exit 1
fi

# Create .kiro directories if they don't exist
if [ ! -d ".kiro" ]; then
    echo "Creating .kiro directory structure..."
    mkdir -p .kiro/steering .kiro/specs
fi

# Set environment variables for templates
export STEERING_DIRECTORY=".kiro/steering"
export SPECS_DIRECTORY=".kiro/specs"
export PROJECT_PATH="$(pwd)"
export PROJECT_NAME="$(basename $(pwd))"

# Prepare template path
TEMPLATE_PATH=".amazonq/templates/${commandName.replace('kiro-', '').replace('-', '-')}.hbs"
if [ ! -f "$TEMPLATE_PATH" ]; then
    echo "Error: Template file not found: $TEMPLATE_PATH"
    exit 1
fi

# Execute Amazon Q CLI with structured prompt
echo "Executing ${commandName}..."

${this.generateExecutionScript(info)}

# Check result
if [ $? -eq 0 ]; then
    echo "${commandName} completed successfully"
else
    echo "Error: Amazon Q CLI command failed"
    exit 1
fi
`;

    return scriptTemplate;
  }

  /**
   * Generate the execution part of the script based on CLI capabilities
   */
  private generateExecutionScript(info: AmazonQCLIInfo): string {
    if (info.supportsFileFlag) {
      // Modern CLI with --file support
      return `${info.command} chat --file "$TEMPLATE_PATH" "$@"`;
    } else {
      // Legacy CLI without --file support - pipe template content
      return `cat "$TEMPLATE_PATH" | ${info.command} chat "$@"`;
    }
  }

  /**
   * Clear cached CLI info (useful for testing)
   */
  clearCache(): void {
    this.cachedInfo = null;
  }
}