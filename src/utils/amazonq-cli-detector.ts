/**
 * Amazon Q CLI Version Detection and Compatibility
 * Detects different versions of Amazon Q CLI and adapts command generation
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { Logger } from './logger';

const execAsync = promisify(exec);

export interface AmazonQCLIInfo {
  /** Available command name (q, qchat, etc.) */
  command: string;
  /** CLI version if detectable */
  version?: string;
  /** Whether it supports --file flag */
  supportsFileFlag: boolean;
  /** Whether it supports --context flag */
  supportsContextFlag: boolean;
  /** Command structure type */
  type: 'q-chat' | 'qchat-chat' | 'unknown';
  /** Full help output for debugging */
  helpOutput?: string;
}

export class AmazonQCLIDetector {
  private logger: Logger;
  private cachedInfo: AmazonQCLIInfo | null = null;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  /**
   * Detect Amazon Q CLI version and capabilities
   */
  async detectCLI(): Promise<AmazonQCLIInfo> {
    if (this.cachedInfo) {
      return this.cachedInfo;
    }

    this.logger.verbose('Detecting Amazon Q CLI version and capabilities...');

    // Try different command variations
    const candidates = [
      { cmd: 'q', subcommand: 'chat' },
      { cmd: 'qchat', subcommand: 'chat' },
      { cmd: 'amazon-q', subcommand: 'chat' },
      { cmd: 'amazonq', subcommand: 'chat' }
    ];

    for (const candidate of candidates) {
      try {
        const info = await this.testCommand(candidate.cmd, candidate.subcommand);
        if (info) {
          this.cachedInfo = info;
          this.logger.verbose(`Detected Amazon Q CLI: ${info.command} (${info.type})`);
          return info;
        }
      } catch (error) {
        this.logger.debug(`Command ${candidate.cmd} not available: ${error}`);
      }
    }

    throw new Error('Amazon Q CLI not found. Please install Amazon Q CLI.');
  }

  /**
   * Test a specific command variant
   */
  private async testCommand(cmd: string, subcommand: string): Promise<AmazonQCLIInfo | null> {
    try {
      // Test if command exists and get help
      const helpResult = await execAsync(`${cmd} ${subcommand} --help`, { 
        timeout: 5000 
      });
      
      const helpOutput = helpResult.stdout + helpResult.stderr;
      
      // Test version command
      let version: string | undefined;
      try {
        const versionResult = await execAsync(`${cmd} --version`, { timeout: 3000 });
        version = versionResult.stdout.trim();
      } catch {
        // Version command might not exist
        this.logger.debug(`No version command for ${cmd}`);
      }

      // Analyze help output to determine capabilities
      const supportsFileFlag = helpOutput.includes('--file') || helpOutput.includes('-f');
      const supportsContextFlag = helpOutput.includes('--context') || helpOutput.includes('--ctx');
      
      // Determine command type
      let type: AmazonQCLIInfo['type'] = 'unknown';
      if (cmd === 'q' && subcommand === 'chat') {
        type = 'q-chat';
      } else if (cmd === 'qchat' && subcommand === 'chat') {
        type = 'qchat-chat';
      }

      return {
        command: cmd,
        version,
        supportsFileFlag,
        supportsContextFlag,
        type,
        helpOutput: helpOutput.substring(0, 1000) // Truncate for logging
      };

    } catch (error) {
      this.logger.debug(`Failed to test ${cmd} ${subcommand}: ${error}`);
      return null;
    }
  }

  /**
   * Generate appropriate command line for given CLI type
   */
  generateCommandLine(info: AmazonQCLIInfo, templatePath?: string, contextFiles?: string[]): string[] {
    const parts = [info.command];
    
    // Add subcommand based on type
    if (info.type === 'q-chat' || info.type === 'qchat-chat') {
      parts.push('chat');
    }

    // Add file flag if supported and template provided
    if (templatePath && info.supportsFileFlag) {
      parts.push('--file', templatePath);
    }

    // Add context files if supported
    if (contextFiles && info.supportsContextFlag) {
      contextFiles.forEach(file => {
        parts.push('--context', file);
      });
    }

    return parts;
  }

  /**
   * Generate script content that works with detected CLI
   */
  generateScriptContent(info: AmazonQCLIInfo, commandName: string, description: string): string {
    const scriptTemplate = `#!/bin/bash
# ${description}
# Generated by amazonq-sdd v0.2.0 - Compatible with ${info.command} (${info.type})

set -euo pipefail

# Check if Amazon Q CLI is available
if ! command -v ${info.command} &> /dev/null; then
    echo "Error: Amazon Q CLI command '${info.command}' not found. Please install Amazon Q CLI."
    echo "Install from: https://aws.amazon.com/q/developer/"
    exit 1
fi

# Check if .amazonq directory exists
if [ ! -d ".amazonq" ]; then
    echo "Error: .amazonq directory not found. Run 'npx amazonq-sdd@latest' first."
    exit 1
fi

# Create .kiro directories if they don't exist
if [ ! -d ".kiro" ]; then
    echo "Creating .kiro directory structure..."
    mkdir -p .kiro/steering .kiro/specs
fi

# Set environment variables for templates
export STEERING_DIRECTORY=".kiro/steering"
export SPECS_DIRECTORY=".kiro/specs"
export PROJECT_PATH="$(pwd)"
export PROJECT_NAME="$(basename $(pwd))"

# Prepare template path
TEMPLATE_PATH=".amazonq/templates/${commandName.replace('kiro-', '').replace('-', '-')}.hbs"
if [ ! -f "$TEMPLATE_PATH" ]; then
    echo "Error: Template file not found: $TEMPLATE_PATH"
    exit 1
fi

# Extract feature name from arguments for file organization
FEATURE_NAME=""
if [ $# -gt 0 ]; then
    FEATURE_NAME="$1"
    # Convert to lowercase and replace spaces with dashes
    FEATURE_NAME=$(echo "$FEATURE_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g' | sed 's/[^a-z0-9-]//g')
fi

# Create feature directory if this is a spec command and we have a feature name
if [[ "${commandName}" == *"spec"* ]] && [ -n "$FEATURE_NAME" ]; then
    FEATURE_DIR=".kiro/specs/$FEATURE_NAME"
    mkdir -p "$FEATURE_DIR"
    echo "üìÅ Created: $FEATURE_DIR/"
fi

# Determine output file for spec commands
OUTPUT_FILE=""
if [[ "${commandName}" == *"spec"* ]] && [ -n "$FEATURE_NAME" ]; then
    case "${commandName}" in
        *"init"*)
            OUTPUT_FILE="$FEATURE_DIR/requirements.md"
            ;;
        *"requirements"*)
            OUTPUT_FILE="$FEATURE_DIR/requirements.md"
            ;;
        *"design"*)
            OUTPUT_FILE="$FEATURE_DIR/design.md"
            ;;
        *"tasks"*)
            OUTPUT_FILE="$FEATURE_DIR/tasks.md"
            ;;
        *"status"*)
            OUTPUT_FILE="$FEATURE_DIR/status.md"
            ;;
    esac
fi

# Execute Amazon Q CLI with structured prompt
echo "Executing ${commandName}..."
echo "==============================================="

if [ -n "$OUTPUT_FILE" ]; then
    # Show relative path for cleaner output
    RELATIVE_FILE=$(echo "$OUTPUT_FILE" | sed 's|^\./||')
    echo "üìù Saving to: $RELATIVE_FILE"
    echo ""
    
    # Capture Amazon Q output and save to file
    {
        echo "# Generated by ${commandName} on \$(date)"
        echo "# Feature: $FEATURE_NAME"
        echo "# Project: \$(basename \$(pwd))"
        echo ""
        
        # Process template with variable substitution and run Amazon Q CLI
        TEMP_OUTPUT=\$(mktemp)
        PROCESSED_TEMPLATE=\$(mktemp)
        
        # Process Handlebars-style variables in template - escape special characters
        ESCAPED_FEATURE_DESC=\$(printf '%s\\n' "\$1" | sed 's/[[\.*^$(){}?+|\\]/\\\\&/g')
        ESCAPED_PROJECT_NAME=\$(printf '%s\\n' "\$PROJECT_NAME" | sed 's/[[\.*^$(){}?+|\\]/\\\\&/g')
        ESCAPED_PROJECT_PATH=\$(printf '%s\\n' "\$PROJECT_PATH" | sed 's/[[\.*^$(){}?+|\\]/\\\\&/g')
        ESCAPED_FEATURE_NAME=\$(printf '%s\\n' "\$FEATURE_NAME" | sed 's/[[\.*^$(){}?+|\\]/\\\\&/g')
        
        sed "s/{{FEATURE_DESCRIPTION}}/\$ESCAPED_FEATURE_DESC/g; s/{{PROJECT_NAME}}/\$ESCAPED_PROJECT_NAME/g; s/{{TECHNOLOGY_STACK}}/Unknown/g; s/{{PROJECT_PATH}}/\$ESCAPED_PROJECT_PATH/g; s/{{ARCHITECTURE_TYPE}}/Standard/g; s/{{FEATURE_NAME}}/\$ESCAPED_FEATURE_NAME/g" "\$TEMPLATE_PATH" > "\$PROCESSED_TEMPLATE"
        
        # Run Amazon Q CLI with processed template
        ${this.generateExecutionScript(info).replace('$TEMPLATE_PATH', '$PROCESSED_TEMPLATE')} > "\$TEMP_OUTPUT" 2>&1
        
        # Filter out Amazon Q CLI UI elements and keep only content
        # First, remove ANSI escape codes, then filter out UI elements
        sed 's/\\x1b\\[[0-9;]*[a-zA-Z]//g' "\$TEMP_OUTPUT" | \\
        sed -E '
            # Remove ASCII art and box characters (including braille patterns)
            /^[[:space:]]*[‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚¢Ä‚¢†‚¢∞‚¢∏‚°Ä‚°Ñ‚°Ü‚°á‚£Ä‚£Ñ‚£Ü‚£á‚£†‚£§‚£¶‚£ß‚£∞‚£¥‚£∂‚£∑‚£∏‚£º‚£æ‚£ø]/d
            /^[[:space:]]*[‚ï≠‚ïÆ‚ïØ‚ï∞‚îÄ‚îÇ‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ïê‚ïë‚ïî‚ïó‚ïö‚ïù‚ï†‚ï£‚ï¶‚ï©‚ï¨]/d  
            /^[[:space:]]*[‚îÅ‚îÉ‚îè‚îì‚îó‚îõ‚î£‚î´‚î≥‚îª‚ïã]/d
            
            # Remove thinking indicators and spinners
            /Thinking\.\.\./d
            /^[‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è]/d
            
            # Remove control sequences and positioning
            /\\[?[0-9]*[hlK]/d
            /\\[[0-9]*[GJK]/d
            /^[[:space:]]*\\[m/d
            
            # Remove help text and UI elements
            /help all commands/d
            /ctrl.*new lines/d  
            /ctrl.*fuzzy search/d
            /You are chatting with/d
            /Did you know/d
            /Get notified whenever/d
            /enableNotifications/d
            /To exit the CLI/d
            /press Ctrl/d
            /type.*quit/d
            
            # Remove Amazon Q branding and logos (ASCII art)
            /Amazon Q/d
            /built by AWS/d
            /I can see you.re in a project directory/d
            /set up for spec-driven development/d
            /Feel free to ask me anything/d
            /what you.d like to work on/d
            
            # Remove lines that are just special characters or formatting
            /^[[:space:]]*[‚îÄ‚îÅ‚îÇ‚îÉ‚ï≠‚ïÆ‚ïØ‚ï∞‚îå‚îê‚îî‚îò‚îú‚î§‚î¨‚î¥‚îº‚ïê‚ïë‚ïî‚ïó‚ïö‚ïù‚ï†‚ï£‚ï¶‚ï©‚ï¨‚†Ä-‚£ø]*[[:space:]]*$$/d
            
            # Remove lines with just numbers and special chars (like cursor positioning)
            /^[[:space:]]*[0-9\\[\\]mKGJ]*[[:space:]]*$$/d
            
            # Remove completely empty lines at start
            1{/^[[:space:]]*$$/d}
            
            # Keep lines that have actual content (letters, words)
            /[a-zA-Z]/!d
            
            # Final cleanup - remove lines that are just escape sequences
            /^[[:space:]]*$$/d
        '
        
        # Clean up
        rm -f "\$TEMP_OUTPUT" "\$PROCESSED_TEMPLATE"
    } > "$OUTPUT_FILE"
    
    # Check result
    if [ $? -eq 0 ]; then
        echo "==============================================="
        echo "‚úÖ ${commandName} completed successfully"
        echo "üìÑ File saved: $RELATIVE_FILE"
        echo ""
        echo "üí° Next steps:"
        echo "   üìñ View: cat $RELATIVE_FILE"
        echo "   ‚úèÔ∏è  Edit: nano $RELATIVE_FILE"
    else
        echo "‚ùå Error: Amazon Q CLI command failed"
        rm -f "$OUTPUT_FILE" 2>/dev/null  # Remove failed output file
        exit 1
    fi
else
    # No output file - just run the command interactively
    ${this.generateExecutionScript(info)}
    
    # Check result
    if [ $? -eq 0 ]; then
        echo "==============================================="
        echo "${commandName} completed successfully"
    else
        echo "Error: Amazon Q CLI command failed"
        exit 1
    fi
fi
`;

    return scriptTemplate;
  }

  /**
   * Generate the execution part of the script based on CLI capabilities
   */
  private generateExecutionScript(info: AmazonQCLIInfo): string {
    if (info.supportsFileFlag) {
      // Modern CLI with --file support
      return `${info.command} chat --file "$TEMPLATE_PATH" "$@"`;
    } else {
      // Legacy CLI without --file support - pipe template content
      return `cat "$TEMPLATE_PATH" | ${info.command} chat "$@"`;
    }
  }

  /**
   * Clear cached CLI info (useful for testing)
   */
  clearCache(): void {
    this.cachedInfo = null;
  }
}