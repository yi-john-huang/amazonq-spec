/**
 * Amazon Q CLI Version Detection and Compatibility
 * Detects different versions of Amazon Q CLI and adapts command generation
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import { Logger } from './logger';

const execAsync = promisify(exec);

export interface AmazonQCLIInfo {
  /** Available command name (q, qchat, etc.) */
  command: string;
  /** CLI version if detectable */
  version?: string;
  /** Whether it supports --file flag */
  supportsFileFlag: boolean;
  /** Whether it supports --context flag */
  supportsContextFlag: boolean;
  /** Command structure type */
  type: 'q-chat' | 'qchat-chat' | 'unknown';
  /** Full help output for debugging */
  helpOutput?: string;
}

export class AmazonQCLIDetector {
  private logger: Logger;
  private cachedInfo: AmazonQCLIInfo | null = null;

  constructor(logger: Logger) {
    this.logger = logger;
  }

  /**
   * Detect Amazon Q CLI version and capabilities
   */
  async detectCLI(): Promise<AmazonQCLIInfo> {
    if (this.cachedInfo) {
      return this.cachedInfo;
    }

    this.logger.verbose('Detecting Amazon Q CLI version and capabilities...');

    // Try different command variations
    const candidates = [
      { cmd: 'q', subcommand: 'chat' },
      { cmd: 'qchat', subcommand: 'chat' },
      { cmd: 'amazon-q', subcommand: 'chat' },
      { cmd: 'amazonq', subcommand: 'chat' }
    ];

    for (const candidate of candidates) {
      try {
        const info = await this.testCommand(candidate.cmd, candidate.subcommand);
        if (info) {
          this.cachedInfo = info;
          this.logger.verbose(`Detected Amazon Q CLI: ${info.command} (${info.type})`);
          return info;
        }
      } catch (error) {
        this.logger.debug(`Command ${candidate.cmd} not available: ${error}`);
      }
    }

    throw new Error('Amazon Q CLI not found. Please install Amazon Q CLI.');
  }

  /**
   * Test a specific command variant
   */
  private async testCommand(cmd: string, subcommand: string): Promise<AmazonQCLIInfo | null> {
    try {
      // Test if command exists and get help
      const helpResult = await execAsync(`${cmd} ${subcommand} --help`, { 
        timeout: 5000 
      });
      
      const helpOutput = helpResult.stdout + helpResult.stderr;
      
      // Test version command
      let version: string | undefined;
      try {
        const versionResult = await execAsync(`${cmd} --version`, { timeout: 3000 });
        version = versionResult.stdout.trim();
      } catch {
        // Version command might not exist
        this.logger.debug(`No version command for ${cmd}`);
      }

      // Analyze help output to determine capabilities
      const supportsFileFlag = helpOutput.includes('--file') || helpOutput.includes('-f');
      const supportsContextFlag = helpOutput.includes('--context') || helpOutput.includes('--ctx');
      
      // Determine command type
      let type: AmazonQCLIInfo['type'] = 'unknown';
      if (cmd === 'q' && subcommand === 'chat') {
        type = 'q-chat';
      } else if (cmd === 'qchat' && subcommand === 'chat') {
        type = 'qchat-chat';
      }

      return {
        command: cmd,
        version,
        supportsFileFlag,
        supportsContextFlag,
        type,
        helpOutput: helpOutput.substring(0, 1000) // Truncate for logging
      };

    } catch (error) {
      this.logger.debug(`Failed to test ${cmd} ${subcommand}: ${error}`);
      return null;
    }
  }

  /**
   * Generate appropriate command line for given CLI type
   */
  generateCommandLine(info: AmazonQCLIInfo, templatePath?: string, contextFiles?: string[]): string[] {
    const parts = [info.command];
    
    // Add subcommand based on type
    if (info.type === 'q-chat' || info.type === 'qchat-chat') {
      parts.push('chat');
    }

    // Add file flag if supported and template provided
    if (templatePath && info.supportsFileFlag) {
      parts.push('--file', templatePath);
    }

    // Add context files if supported
    if (contextFiles && info.supportsContextFlag) {
      contextFiles.forEach(file => {
        parts.push('--context', file);
      });
    }

    return parts;
  }

  /**
   * Generate script content that works with detected CLI
   */
  generateScriptContent(info: AmazonQCLIInfo, commandName: string, description: string): string {
    const scriptTemplate = `#!/bin/bash
# ${description}
# Generated by amazonq-sdd v0.2.0 - Compatible with ${info.command} (${info.type})

set -euo pipefail

# Check if Amazon Q CLI is available
if ! command -v ${info.command} &> /dev/null; then
    echo "Error: Amazon Q CLI command '${info.command}' not found. Please install Amazon Q CLI."
    echo "Install from: https://aws.amazon.com/q/developer/"
    exit 1
fi

# Check if .amazonq directory exists
if [ ! -d ".amazonq" ]; then
    echo "Error: .amazonq directory not found. Run 'npx amazonq-sdd@latest' first."
    exit 1
fi

# Create .kiro directories if they don't exist
if [ ! -d ".kiro" ]; then
    echo "Creating .kiro directory structure..."
    mkdir -p .kiro/steering .kiro/specs
fi

# Set environment variables for templates
export STEERING_DIRECTORY=".kiro/steering"
export SPECS_DIRECTORY=".kiro/specs"
export PROJECT_PATH="$(pwd)"
export PROJECT_NAME="$(basename $(pwd))"

# Prepare template path
TEMPLATE_PATH=".amazonq/templates/${commandName.replace('kiro-', '').replace('-', '-')}.hbs"
if [ ! -f "$TEMPLATE_PATH" ]; then
    echo "Error: Template file not found: $TEMPLATE_PATH"
    exit 1
fi

# Extract feature name from arguments for file organization
FEATURE_NAME=""
if [ $# -gt 0 ]; then
    FEATURE_NAME="$1"
    # Convert to lowercase and replace spaces with dashes
    FEATURE_NAME=$(echo "$FEATURE_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g' | sed 's/[^a-z0-9-]//g')
fi

# Create feature directory if this is a spec command and we have a feature name
if [[ "${commandName}" == *"spec"* ]] && [ -n "$FEATURE_NAME" ]; then
    FEATURE_DIR=".kiro/specs/$FEATURE_NAME"
    mkdir -p "$FEATURE_DIR"
    echo "ðŸ“ Created: $FEATURE_DIR/"
fi

# Determine output file for spec commands
OUTPUT_FILE=""
if [[ "${commandName}" == *"spec"* ]] && [ -n "$FEATURE_NAME" ]; then
    case "${commandName}" in
        *"init"*)
            OUTPUT_FILE="$FEATURE_DIR/specification.md"
            ;;
        *"requirements"*)
            OUTPUT_FILE="$FEATURE_DIR/requirements.md"
            ;;
        *"design"*)
            OUTPUT_FILE="$FEATURE_DIR/design.md"
            ;;
        *"tasks"*)
            OUTPUT_FILE="$FEATURE_DIR/tasks.md"
            ;;
        *"status"*)
            OUTPUT_FILE="$FEATURE_DIR/status.md"
            ;;
    esac
fi

# Execute Amazon Q CLI with structured prompt
echo "Executing ${commandName}..."
echo "==============================================="

if [ -n "$OUTPUT_FILE" ]; then
    # Show relative path for cleaner output
    RELATIVE_FILE=$(echo "$OUTPUT_FILE" | sed 's|^\./||')
    echo "ðŸ“ Saving to: $RELATIVE_FILE"
    echo ""
    
    # Capture Amazon Q output and save to file
    {
        echo "# Generated by ${commandName} on \$(date)"
        echo "# Feature: $FEATURE_NAME"
        echo "# Project: \$(basename \$(pwd))"
        echo ""
        ${this.generateExecutionScript(info)} 2>&1
    } > "$OUTPUT_FILE"
    
    # Check result
    if [ $? -eq 0 ]; then
        echo "==============================================="
        echo "âœ… ${commandName} completed successfully"
        echo "ðŸ“„ File saved: $RELATIVE_FILE"
        echo ""
        echo "ðŸ’¡ Next steps:"
        echo "   ðŸ“– View: cat $RELATIVE_FILE"
        echo "   âœï¸  Edit: nano $RELATIVE_FILE"
    else
        echo "âŒ Error: Amazon Q CLI command failed"
        rm -f "$OUTPUT_FILE" 2>/dev/null  # Remove failed output file
        exit 1
    fi
else
    # No output file - just run the command interactively
    ${this.generateExecutionScript(info)}
    
    # Check result
    if [ $? -eq 0 ]; then
        echo "==============================================="
        echo "${commandName} completed successfully"
    else
        echo "Error: Amazon Q CLI command failed"
        exit 1
    fi
fi
`;

    return scriptTemplate;
  }

  /**
   * Generate the execution part of the script based on CLI capabilities
   */
  private generateExecutionScript(info: AmazonQCLIInfo): string {
    if (info.supportsFileFlag) {
      // Modern CLI with --file support
      return `${info.command} chat --file "$TEMPLATE_PATH" "$@"`;
    } else {
      // Legacy CLI without --file support - pipe template content
      return `cat "$TEMPLATE_PATH" | ${info.command} chat "$@"`;
    }
  }

  /**
   * Clear cached CLI info (useful for testing)
   */
  clearCache(): void {
    this.cachedInfo = null;
  }
}